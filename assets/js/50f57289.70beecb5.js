"use strict";(self.webpackChunkeliza_docs=self.webpackChunkeliza_docs||[]).push([[90173],{24095:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"tutorials/part3","title":"Part 3: Building a User Data Extraction Agent","description":"Building a User Data Extraction Agent","source":"@site/docs/tutorials/part3.md","sourceDirName":"tutorials","slug":"/tutorials/part3","permalink":"/eliza/docs/tutorials/part3","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/main/docs/docs/tutorials/part3.md","tags":[],"version":"current","lastUpdatedBy":"madjin","lastUpdatedAt":1739414584000,"frontMatter":{"Title":"AI Agent Dev School Part 3","description":"Building a User Data Extraction Agent"},"sidebar":"tutorialSidebar","previous":{"title":"Part 2","permalink":"/eliza/docs/tutorials/part2"},"next":{"title":"Clone Yourself in 10min","permalink":"/eliza/docs/tutorials/nader_tutorial_10min"}}');var a=t(74848),r=t(28453);const o={Title:"AI Agent Dev School Part 3",description:"Building a User Data Extraction Agent"},s="Part 3: Building a User Data Extraction Agent",l={},c=[];function d(e){const n={a:"a",code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"part-3-building-a-user-data-extraction-agent",children:"Part 3: Building a User Data Extraction Agent"})}),"\n",(0,a.jsx)(n.p,{children:"In this third session of the AI Agent Dev School series, we dive into a practical application of providers and evaluators in the Eliza framework - building an agent that can extract key user data (name, location, job) through natural conversation."}),"\n",(0,a.jsx)(n.p,{children:"We explore:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"The provider-evaluator loop for gathering information and triggering actions"}),"\n",(0,a.jsx)(n.li,{children:"Deep dive into evaluators and their role in agent self-reflection"}),"\n",(0,a.jsx)(n.li,{children:"Code walkthrough of real-world evaluators and providers"}),"\n",(0,a.jsx)(n.li,{children:"Building a user data extraction flow from scratch"}),"\n",(0,a.jsx)(n.li,{children:"Dynamic providers based on completion state"}),"\n",(0,a.jsx)(n.li,{children:"Q&A on advanced topics and use cases"}),"\n"]}),"\n",(0,a.jsx)(n.h1,{id:"key-sections",children:"Key Sections"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=0",children:[(0,a.jsx)(n.strong,{children:"00:00:00"})," - Intro & Housekeeping"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=485",children:[(0,a.jsx)(n.strong,{children:"00:08:05"})," - Building a Form-Filling Agent"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=975",children:[(0,a.jsx)(n.strong,{children:"00:16:15"})," - Deep Dive into Evaluators"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=1675",children:[(0,a.jsx)(n.strong,{children:"00:27:45"}),' - Code walkthrough of the "Fact Evaluator"']})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=2167",children:[(0,a.jsx)(n.strong,{children:"00:36:07"})," - Building a User Data Evaluator"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=3110",children:[(0,a.jsx)(n.strong,{children:"00:51:50"})," - Exploring Eliza's Cache Manager"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=3961",children:[(0,a.jsx)(n.strong,{children:"01:06:01"})," - Using Claude AI for Code Generation"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=4878",children:[(0,a.jsx)(n.strong,{children:"01:21:18"})," - Testing the User Data Flow"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=5427",children:[(0,a.jsx)(n.strong,{children:"01:30:27"})," - Adding a Dynamic Provider Based on Completion"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=5836",children:[(0,a.jsx)(n.strong,{children:"01:37:16"})," - Q&A with the Audience"]})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=Y1DiqSVy4aU&t=6451",children:[(0,a.jsx)(n.strong,{children:"01:47:31"})," - Outro and Next Steps"]})}),"\n"]}),"\n",(0,a.jsx)(n.h1,{id:"the-provider-evaluator-loop",children:"The Provider-Evaluator Loop"}),"\n",(0,a.jsx)(n.p,{children:"A key concept introduced in this session is the provider-evaluator loop for gathering information and triggering actions:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"The provider checks the cache/database for information we already have"}),"\n",(0,a.jsx)(n.li,{children:"If information is missing, the provider indicates to the agent what it needs to extract"}),"\n",(0,a.jsx)(n.li,{children:"The evaluator extracts new information from user messages and stores it"}),"\n",(0,a.jsx)(n.li,{children:"Once all required information is gathered, the evaluator triggers a completion action"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"This loop allows agents to dynamically gather required data through natural conversation, enabling powerful form-filling and user profiling applications."}),"\n",(0,a.jsx)(n.h1,{id:"deep-dive-into-evaluators",children:"Deep Dive into Evaluators"}),"\n",(0,a.jsx)(n.p,{children:"Evaluators in Eliza run after each agent action, allowing the agent to reflect on what happened and potentially trigger additional actions. Some key aspects of evaluators:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Defined by ",(0,a.jsx)(n.code,{children:"validate"})," and ",(0,a.jsx)(n.code,{children:"handler"})," functions"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"validate"})," determines if the evaluator should run based on the current context"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"handler"})," contains the core evaluator logic - state updates, data extraction, triggering actions, etc."]}),"\n",(0,a.jsx)(n.li,{children:"Evaluators work in close conjunction with providers to extract insights and inject them into future context"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Common use cases include extracting conversation facts, analyzing sentiment, identifying intents, and implementing feedback loops."}),"\n",(0,a.jsx)(n.h1,{id:"building-the-user-data-extraction-flow",children:"Building the User Data Extraction Flow"}),"\n",(0,a.jsx)(n.p,{children:"The hands-on portion of the session focuses on building a user data extraction flow from scratch. Key steps include:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Creating a basic ",(0,a.jsx)(n.code,{children:"UserDataEvaluator"})," and ",(0,a.jsx)(n.code,{children:"UserDataProvider"})]}),"\n",(0,a.jsx)(n.li,{children:"Registering them directly in the agent (without a plugin)"}),"\n",(0,a.jsxs)(n.li,{children:["Leveraging Eliza's ",(0,a.jsx)(n.code,{children:"CacheManager"})," for efficient key-value storage"]}),"\n",(0,a.jsx)(n.li,{children:"Iteratively developing the extraction logic with the help of Claude AI"}),"\n",(0,a.jsx)(n.li,{children:"Testing the flow by interacting with the agent and inspecting logs/context"}),"\n",(0,a.jsx)(n.li,{children:"Adding a dynamic provider that triggers only after data collection is complete"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Through this process, we see how providers and evaluators work together to enable complex, stateful agent behaviors."}),"\n",(0,a.jsx)(n.h1,{id:"using-ai-assistants-in-development",children:"Using AI Assistants in Development"}),"\n",(0,a.jsx)(n.p,{children:"A notable aspect of the session is the use of Claude AI to aid in code development. By providing clear instructions and iterating based on the generated code, complex logic can be developed rapidly."}),"\n",(0,a.jsx)(n.p,{children:"This showcases the potential for AI pair programming and how future developers might interact with their AI counterparts to build sophisticated applications."}),"\n",(0,a.jsx)(n.h1,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Providers and evaluators are the key to stateful, dynamic agent behaviors"}),"\n",(0,a.jsx)(n.li,{children:"The provider-evaluator loop is a powerful pattern for gathering information and triggering actions"}),"\n",(0,a.jsx)(n.li,{children:"Evaluators enable agent self-reflection and adaptation based on conversation context"}),"\n",(0,a.jsx)(n.li,{children:"AI assistants can significantly accelerate development by generating and refining code"}),"\n",(0,a.jsx)(n.li,{children:"The potential for provider-evaluator based applications is immense - form-filling, user profiling, dynamic content unlocking, and more"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"With these tools in hand, developers have a solid foundation for building highly interactive, personalized agentic applications. The next frontier is to explore advanced use cases and further push the boundaries of what's possible with Eliza."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},28453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>s});var i=t(96540);const a={},r=i.createContext(a);function o(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);