"use strict";(self.webpackChunk_elizaos_docs=self.webpackChunk_elizaos_docs||[]).push([[12952],{34310:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>d,metadata:()=>t,toc:()=>a});const t=JSON.parse('{"id":"core/worlds","title":"Worlds","description":"Worlds in ElizaOS are collections of entities (users, agents) and rooms (conversations, channels) that form a cohesive environment for interactions. Think of a world as a virtual space, like a Discord server, Slack workspace, or 3D MMO environment, where entities can communicate across multiple channels or areas.","source":"@site/docs/core/worlds.md","sourceDirName":"core","slug":"/core/worlds","permalink":"/docs/core/worlds","draft":false,"unlisted":false,"editUrl":"https://github.com/elizaos/eliza/tree/main/docs/docs/core/worlds.md","tags":[],"version":"current","lastUpdatedBy":"Shaw","lastUpdatedAt":1742108548000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7},"sidebar":"tutorialSidebar","previous":{"title":"Tasks","permalink":"/docs/core/tasks"},"next":{"title":"Overview","permalink":"/docs/cli/overview"}}');var s=r(31085),i=r(71184);const d={sidebar_position:7},l="Worlds",o={},a=[{value:"World Structure",id:"world-structure",level:2},{value:"World Creation and Management",id:"world-creation-and-management",level:2},{value:"Creating a World",id:"creating-a-world",level:3},{value:"Ensuring a World Exists",id:"ensuring-a-world-exists",level:3},{value:"Retrieving World Information",id:"retrieving-world-information",level:3},{value:"Updating World Properties",id:"updating-world-properties",level:3},{value:"World Roles System",id:"world-roles-system",level:2},{value:"Managing Roles",id:"managing-roles",level:3},{value:"World Settings",id:"world-settings",level:2},{value:"World Events",id:"world-events",level:2},{value:"Handling World Events",id:"handling-world-events",level:3},{value:"Relationship with Rooms",id:"relationship-with-rooms",level:2},{value:"Best Practices",id:"best-practices",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"worlds",children:"Worlds"})}),"\n",(0,s.jsx)(n.p,{children:"Worlds in ElizaOS are collections of entities (users, agents) and rooms (conversations, channels) that form a cohesive environment for interactions. Think of a world as a virtual space, like a Discord server, Slack workspace, or 3D MMO environment, where entities can communicate across multiple channels or areas."}),"\n",(0,s.jsx)(n.h2,{id:"world-structure",children:"World Structure"}),"\n",(0,s.jsx)(n.p,{children:"A world in ElizaOS has the following properties:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"type World = {\n  id: UUID;\n  name?: string;\n  agentId: UUID;\n  serverId: string;\n  metadata?: {\n    ownership?: {\n      ownerId: string;\n    };\n    roles?: {\n      [entityId: UUID]: Role;\n    };\n    [key: string]: unknown;\n  };\n};\n"})}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Property"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"id"})}),(0,s.jsx)(n.td,{children:"Unique identifier for the world"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"name"})}),(0,s.jsx)(n.td,{children:"Optional display name"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"agentId"})}),(0,s.jsx)(n.td,{children:"ID of the agent managing this world"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"serverId"})}),(0,s.jsx)(n.td,{children:"External system identifier (e.g., Discord server ID)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"metadata"})}),(0,s.jsx)(n.td,{children:"Additional world configuration data"})]})]})]}),"\n",(0,s.jsx)(n.p,{children:"The metadata can store custom information, including ownership details and role assignments for entities within the world."}),"\n",(0,s.jsx)(n.h2,{id:"world-creation-and-management",children:"World Creation and Management"}),"\n",(0,s.jsx)(n.h3,{id:"creating-a-world",children:"Creating a World"}),"\n",(0,s.jsx)(n.p,{children:"You can create a new world using the AgentRuntime:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"const worldId = await runtime.createWorld({\n  name: 'My Project Space',\n  agentId: runtime.agentId,\n  serverId: 'external-system-id',\n  metadata: {\n    ownership: {\n      ownerId: ownerEntityId,\n    },\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"For many integrations, worlds are automatically created during connection setup with external platforms like Discord or Slack."}),"\n",(0,s.jsx)(n.h3,{id:"ensuring-a-world-exists",children:"Ensuring a World Exists"}),"\n",(0,s.jsxs)(n.p,{children:["If you're not sure if a world exists, you can use ",(0,s.jsx)(n.code,{children:"ensureWorldExists()"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"await runtime.ensureWorldExists({\n  id: worldId,\n  name: 'My Project Space',\n  agentId: runtime.agentId,\n  serverId: 'external-system-id',\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"retrieving-world-information",children:"Retrieving World Information"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get a specific world\nconst world = await runtime.getWorld(worldId);\n\n// Get all worlds\nconst allWorlds = await runtime.getAllWorlds();\n"})}),"\n",(0,s.jsx)(n.h3,{id:"updating-world-properties",children:"Updating World Properties"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"await runtime.updateWorld({\n  id: worldId,\n  name: 'Updated Name',\n  metadata: {\n    ...world.metadata,\n    customProperty: 'value',\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h2,{id:"world-roles-system",children:"World Roles System"}),"\n",(0,s.jsx)(n.p,{children:"Worlds support a role-based permission system with the following roles:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Role"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"OWNER"})}),(0,s.jsx)(n.td,{children:"Full control over the world, can assign any roles"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"ADMIN"})}),(0,s.jsx)(n.td,{children:"Administrative capabilities, can manage most settings"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"NONE"})}),(0,s.jsx)(n.td,{children:"Standard participant with no special permissions"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"managing-roles",children:"Managing Roles"}),"\n",(0,s.jsx)(n.p,{children:"Roles are stored in the world's metadata and can be updated:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get existing world\nconst world = await runtime.getWorld(worldId);\n\n// Ensure roles object exists\nif (!world.metadata) world.metadata = {};\nif (!world.metadata.roles) world.metadata.roles = {};\n\n// Assign a role to an entity\nworld.metadata.roles[entityId] = Role.ADMIN;\n\n// Save the world\nawait runtime.updateWorld(world);\n"})}),"\n",(0,s.jsx)(n.p,{children:"For programmatic role management, you can use role-related utilities:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { canModifyRole, findWorldForOwner } from '@elizaos/core';\n\n// Check if user can modify roles\nif (canModifyRole(userRole, targetRole, newRole)) {\n  // Allow role change\n}\n\n// Find world where user is owner\nconst userWorld = await findWorldForOwner(runtime, entityId);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"world-settings",children:"World Settings"}),"\n",(0,s.jsx)(n.p,{children:"Worlds support configurable settings that can be stored and retrieved:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get settings for a world\nconst worldSettings = await getWorldSettings(runtime, serverId);\n\n// Update world settings\nworldSettings.MY_SETTING = {\n  name: 'My Setting',\n  description: 'Description for users',\n  value: 'setting-value',\n  required: false,\n};\n\n// Save settings\nawait updateWorldSettings(runtime, serverId, worldSettings);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"world-events",children:"World Events"}),"\n",(0,s.jsx)(n.p,{children:"ElizaOS emits events related to world activities:"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Event"}),(0,s.jsx)(n.th,{children:"Description"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"WORLD_JOINED"})}),(0,s.jsx)(n.td,{children:"Emitted when an agent joins a world"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"WORLD_CONNECTED"})}),(0,s.jsx)(n.td,{children:"Emitted when a world is successfully connected"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"WORLD_LEFT"})}),(0,s.jsx)(n.td,{children:"Emitted when an agent leaves a world"})]})]})]}),"\n",(0,s.jsx)(n.h3,{id:"handling-world-events",children:"Handling World Events"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Register event handlers in your plugin\nconst myPlugin: Plugin = {\n  name: 'my-world-plugin',\n  description: 'Handles world events',\n\n  events: {\n    [EventTypes.WORLD_JOINED]: [\n      async (payload: WorldPayload) => {\n        const { world, runtime } = payload;\n        console.log(`Joined world: ${world.name}`);\n      },\n    ],\n\n    [EventTypes.WORLD_LEFT]: [\n      async (payload: WorldPayload) => {\n        const { world, runtime } = payload;\n        console.log(`Left world: ${world.name}`);\n      },\n    ],\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"relationship-with-rooms",children:"Relationship with Rooms"}),"\n",(0,s.jsxs)(n.p,{children:["A world contains multiple rooms that entities can interact in. Each room points back to its parent world via the ",(0,s.jsx)(n.code,{children:"worldId"})," property."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Get all rooms in a world\nconst worldRooms = await runtime.getRooms(worldId);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["See the ",(0,s.jsx)(n.a,{href:"/docs/core/rooms",children:"Rooms"})," documentation for more details on managing rooms within worlds."]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Always check permissions"}),": Before performing administrative actions, verify the user has appropriate roles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Handle world metadata carefully"}),": The metadata object can contain critical configuration, so modify it with care"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"World-room syncing"}),": When syncing with external platforms, keep world and room structures in alignment"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Event-driven architecture"}),": Use events to respond to world changes rather than polling for updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Default settings"}),": Provide sensible defaults for world settings to make configuration easier"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},71184:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>l});var t=r(14041);const s={},i=t.createContext(s);function d(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);